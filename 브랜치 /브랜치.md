# 브랜치

## 브랜치(branch)란?

`브랜치(branch)`란 '하나의 코드 관리 흐름'으로 나뭇가지라는 뜻을 가지고 있다. 여기서 나뭇가지란 git은 맨 처음 커밋인 root commit을 시작으로 가지가 갈라지는 나무 모양을 하고있는데 이 가지 하나하나를 브랜치라고 생각하면 된다. 예를 들어 하나의 프로젝트에서 유료버전과 무료버전을 제공할때 이를 따로따로 만들기 보다는 유료, 무료로 브랜치를 2개로 나눈 후 이 안에서 또 브랜치를 나눠가며 만드는 것이 효율적이다.

처음 커밋을 하게 되면 `메인(master) 브랜치`위에 있게되는데 이는 레포지토리를 만들고 커밋을 하면 자동으로 생기는 기본 브랜치이다.

브랜치를 만들기 위한 명령어는 아래와 같다.

```
git branch [브랜치 명]
```

위처럼 브랜치를 만들면 지금까지 작업한 내용들이 모두 해당 브랜치에도 속하게된다. 브랜치를 만들고 그 위에서 작업하기 위해서는 반드시 아래 명령어를 통해 만든 브랜치로 먼저 이동을 해야한다.

```
git checkout [브랜치 명]
```

`git status` 명령어를 통해서 현재 브랜치 위치를 파악할 수 있다.

## 브랜치 다루기

- `git branch` : 브랜치 조회
- `git branch [브랜치 명]` : 브랜치 생성
- `git branch -d [브랜치 명]` : 해당 브랜치 삭제
- `git checkout -b [브랜치 명]` : 브랜치를 새로 만들고 그 브랜치로 이동 (보통 브랜치를 만들고 바로 이동해서 작업하므로 자주 쓰이는 명령어)

## 브랜치 merge

만약, 무료 버전과 유료 버전을 브랜치로 나눠 작업하는 경우에 무료 버전의 모든 기능이 유료 버전에서도 있어야한다면 무료 버전에 기능들을 유료 버전의 브랜치로 이동한 후 복사하는 방법을 생각할 수 있다. 하지만 git에서는 다른 브랜치에서 한 커밋을 그대로 다른 브랜치에도 반영하는게 가능하며 이러한 작업을 `branch merge`라고 한다.

`merge`기능을 사용하기 위해서는 아래와 같은 명령어를 사용하면 된다.

```
git merge [반영하고 싶은 브랜치 이름]
```

즉 a 브랜치에서 `git merge b` 명령어를 사용할 경우 '현재 위치인 a 브랜치에 b 브랜치를 합치겠다' 라는 의미가된다. (먼저 작업할 브랜치로 이동한 후, 합병할 브랜치를 명령어로 머지)

명령어 입력 후 나타나는 텍스트 에디터에서 `:wq`를 통해 저장하면 머지가 되었다는 문구가 출력되며 머지가 완료된다.

## conflict

머지를 진행할 경우 파일간 충돌이 일어날 수 있는데 이를 `conflict`라고 한다. 예를 들어, 각각의 브랜치에서 같은 함수를 서로 다른 이름으로 표기했을 경우 이와 같은 일이 일어날 수 있는데 이러한 상황에서 두 브랜치를 merge하려할 경우 git이 둘 중 무엇을 반영해야할지 알 수 없으므로 `conflict`가 발생하게 된다.

<img src = "./image1.png">
위를 보면 HEAD 부분은 현재 작업하고 있는 브랜치이고, 가운데 ===== 선을 기준으로 아래 부분은 합병할 브랜치내에서 충돌이 일어난 부분이다.

이를 해결하기 위해서는

1. 컨플릭트가 발생한 파일을 열고
2. 머지의 결과가 되었으면 하는 모습대로 코드를 수정한 후
3. 커밋을 진행

하면된다.

또한, conflict를 해결하고 싶지 않고 '머지를 시도하기 이전의 상태로 돌아가고 싶다'라고 한다면 아래 명령어를 통해 merge 자체를 취소할 수 있다.

```
git merge --abort
```

conflict 발생시 위의 명령어를 실행하면 해당 브랜치에서 작업 하던 원래 모습 그대로 즉, 머지를 시도하기 이전 모습으로 파일이 돌아오는 것을 확인할 수 있다.

보통 꼭 머지를 해야하는 상황이라면 conflict를 해결하고 커밋을 하는게 정석이지만

- `conflict`가 발생한 파일이 너무 많아 `conflict`를 최소화할 수 있는 방식으로 파일들을 다시 수정하고 커밋한 다음 `merge`를 하고 싶은 경우
- 굳이 지금이 아니더라도 좀 더 나중에 `merge`해도 되는 경우

라면 위의 명령어를 통해 `merge` 자체를 취소해도 된다.

실무에서는 여러 개의 파일을 수정하다보니 머지할 때 conflict도 파일 여러 개에서 나는 경우가 많은데 이럴때도 파일 하나일때와 마찬가지로 원리는 같다. 즉,

- 파일 하나씩 `conflict`를 해결하고 `git add [파일 이름]` 커맨드로 하나씩 `staging area`에 올리거나(중간중간에 `git status` 커맨드로 현재 상태 확인하면서)
- 모든 파일들의 `conflict`를 다 해결하고, `git add .` 커맨드로 한번에 staging area에 올린 후

커밋을 하면 된다.

## remote repository의 브랜치

처음 깃허브를 시작할때

GitHub에서 Math_Box라는 리모트 레포지토리(remote repository)를 만들고 로컬 레포지토리(local repository)의 내용을 그 리모트 레포지토리에 보내기위해 아래와 같은 커맨드 2개를 실행했었는데

```
git remote add origin [주소]

git push -u origin master
```

그 의미를 알아보자.

### origin이란?

먼저 첫 번째 커맨드를 살펴보자.

```
git remote add origin [주소]
```

이 커맨드에서 `remote`는 리모트 레포지토리에 관한 작업을 할 때 쓰는 커맨드이며, 그 뒤의 `add`는 새로운 리모트 레포지토리를 등록하겠다는 뜻이다.

그 다음에는 `origin [주소]`인데, 이 표현은 해당 주소 리모트 레포지토리를 `origin`이라는 이름으로 등록하겠다는 뜻이다.

그러니까 이 커맨드를 실행하고 나면 해당 주소를 `origin`으로 간단하게 나타낼 수 있게 되는 것인데, 왜 하필 origin이라고 하는 걸까?

origin이 아닌 원하는 다른 단어를 입력해도 큰 상관은 없지만 Git에서는 리모트 레포지토리를 최초로 추가할 때 origin이라는 이름으로 가리키는 것이 관례화되어있다.

origin은 ‘근원’, ‘기원’이라는 뜻을 가지는데 다른 사람의 리모트 레포지토리를 자신의 컴퓨터로 가져와서 작업을 하는 사람의 입장에서는 리모트 레포지토리가 프로젝트의 근원이 되는 존재이기 때문에 그런 관습이 생긴 것으로 추측된다.

사실 아래와 같이

```
 git remote add hello [주소]
```

처럼 origin 대신 우리가 원하는 단어(hello)를 써도 상관은 없지만, 되도록 관례에 따라 origin을 써주는 게 좋다.

### Remote Repositoy에 있는 브랜치

이제 두 번째 커맨드를 살펴보자.

```
git push -u origin master
```

이 커맨드의 뜻은 현재 로컬 레포지토리에 있는 `master` 브랜치의 내용(=master 브랜치와 관계된 모든 커밋들)을
`origin`이라는 리모트 레포지토리로 보낸다는 뜻이다.

이때 같은 이름의 브랜치로 전송하게 되는데 만약 `origin`이라는 리모트 레포지토리에 `master` 브랜치가 없으면 `master` 브랜치를 새로 생성하고 푸시한다.

그런데 여기서 옵션 `-u`는 무엇일까? `-u`는 `--set-upstream`이라는 옵션의 약자로, 해당 옵션을 주면
로컬 레포지토리에 있는 `master` 브랜치가
`origin`에 있는 `master` 브랜치를 `tracking(추적)`하는 걸로 설정된다.

`tracking`이라는 건 로컬 레포지토리의 한 브랜치가 리모트 레포지토리의 한 브랜치와 연결되어 그것을 계속 바라보는 상태가 되는 것이라고 생각하면 된다. 이렇게 맺어진 연결 상태를 `tracking connection`이라고 한다.

만약

로컬 레포지토리에 A라는 브랜치가 있고,
리모트 레포지토리에 B라는 브랜치가 있을 때
이런 `tracking connection`이 서로 맺어진 경우,
**B 브랜치를 A 브랜치의 `upstream branch`라고 합니다.**
지금은 구별하기 위해서 A와 B라고 표현했지만 보통은 같은 이름인 경우가 대부분이다.

이렇게 `tracking connection`이 한번 설정되고 나면, 사용자가 현재 `master` 브랜치에 위치해있을 때,

```
git push
```

라고만 써도 자동으로 리모트 레포지토리의 `master` 브랜치를 대상으로 `git push`가 동작하고,

```
git pull
```

라고만 써도 리모트 레포지토리의 `master` 브랜치를 대상으로 `git pull`이 동작한다.

사실 `--set-upstream(-u)` 옵션을 주지 않아도 그 후에 `git push`와 `git pull`을 할 수 있지만 맨 처음, 이 옵션을 주지 않으면 `tracking connection`이 없기 때문에 나중에 `git push`를 하고 싶을 때

```
git push origin master:master
```

이런 식으로 적어줘야 한다.

여기서 `origin`은 리모트 레포지토리를 나타내고,
`master:master`에서 더 먼저 나오는 master는 로컬 레포지토리의 master 브랜치(~에서)/더 뒤에 나오는 master는 리모트 레포지토리의 master 브랜치(~으로)를 나타낸다.
그러니까 `tracking connection`이 없으면 매번 이런 식으로 `git push`를 해줘야 한다. `git pull`도 마찬가지로 이런 식의 복잡한 표현이 필요하게 된다.

그러므로 그냥 처음부터 `tracking connection`을 설정하고 그 이후부터는 `git push`, `git pull`이라고만 써서 편하게 푸시와 풀을 하는 게 좋다.

### origin/master의 의미

위에서 살펴본대로 로컬 레포지토리의 master 브랜치, 리모트 레포지토리의 master 브랜치 이렇게 같은 이름이지만, 서로 다른 2개의 브랜치가 있다는 걸 알 수 있다.

그럼 리모트 레포지토리에 있는 master 브랜치는 어떻게 볼 수 있을까?이는 GitHub 페이지에서 보면 되지만 본인의 컴퓨터에서도 확인할 수 있는 방법이 있다. 잠깐 커밋 히스토리를 살펴보면

<img src = "./image2.png">

위 그림에서

`master`가 로컬 레포지토리의 master 브랜치를 나타내고,
`origin/master`가 리모트 레포지토리의 master 브랜치를 나타낸다.

위의 경우 로컬 레포지토리의 master 브랜치에서 여러 커밋을 했지만 그러고나서 `git push`를 하지 않아 `origin/master`가 `master`보다 이전의 커밋을 가리키고 있다.

## HEAD와 bracn의 관계

HEAD와 마찬가지로 branch 역시 '어떤 커밋을 가리키는 존재'이다.

깃에서 처음 커밋을 하게 되면 마스터 브랜치가 해당 커밋을 가리키며 이후 커밋을 할때마다 해당 커밋을 가리키게 된다.

<img src = "./image3.png">

이전에 HEAD 역시 '어떤 커밋을 가리키는 존재'라고 설명했는데 이는 좀 더 정확히 말하면 HEAD는 branch를 가리키게 된다.

<img src = "./image4.png">

위의 사진을 보면 HEAD는 master branch를 통해 간접적으로 커밋을 가리키고 있는 것을 확인할 수 있다. 이후 커밋을 하면 master 브랜치는 해당 커밋을 가리키며 HEAD는 master 브랜치를 가리키게 때문에 HEAD 역시 해당 커밋을 가리키게 되는 것이다.

여기서 새로운 브랜치를 만들고 `git checkout`을 통해 해당 브랜치로 이동하게 되면 아래 사진처럼 HEAD가 해당 브랜치를 가리키게된다. 즉 `git checkout`은 HEAD가 가리키는 브랜치를 바꾸는 작업인 것이다.

<img src = "./image5.png">

이후 만든 새로운 브랜치에서 커밋을 하고 다시 checkout을 통해 HEAD를 master로 옮기면 아래 그림이 되는데

<img src = "./image6.png">

이후 새롭게 커밋을 하게 되면 커밋 히스토리의 흐름이 아래처럼 바뀌며 이를 `분기한다`라고 한다.

<img src = "./image7.png">

이후 각 브랜치에서 개별적으로 몇 번의 커밋을 더 진행한 후 이를 merge하면 아래와 같이 된다.

<img src = "./image8.png">

위를 보면 두 브랜치를 merge하면 '머지 커밋'이 생기게 된다. 즉 merge란 **헤드가 가리키던 커밋에 다른 브랜치가 가리키던 커밋을 합쳐 새로운 커밋을 만드는 작업**임을 알 수 있다.
